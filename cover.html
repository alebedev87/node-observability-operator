
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>nodeobservability: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lmzuccarelli/node-observability-operator/pkg/operator/controller/nodeobservability/controller.go (66.7%)</option>
				
				<option value="file1">github.com/lmzuccarelli/node-observability-operator/pkg/operator/controller/nodeobservability/daemonset.go (78.6%)</option>
				
				<option value="file2">github.com/lmzuccarelli/node-observability-operator/pkg/operator/controller/nodeobservability/rbac.go (74.5%)</option>
				
				<option value="file3">github.com/lmzuccarelli/node-observability-operator/pkg/operator/controller/nodeobservability/scc.go (75.0%)</option>
				
				<option value="file4">github.com/lmzuccarelli/node-observability-operator/pkg/operator/controller/nodeobservability/secret.go (75.0%)</option>
				
				<option value="file5">github.com/lmzuccarelli/node-observability-operator/pkg/operator/controller/nodeobservability/serviceaccount.go (73.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package nodeobservabilitycontroller

import (
        "context"
        "fmt"

        "github.com/lmzuccarelli/node-observability-operator/api/v1alpha1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        utilclock "k8s.io/apimachinery/pkg/util/clock"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"

        "github.com/go-logr/logr"
)

var (
        clock utilclock.Clock = utilclock.RealClock{}
)

// NodeObservabilityReconciler reconciles a NodeObservability object
type NodeObservabilityReconciler struct {
        client.Client
        Log    logr.Logger
        Scheme *runtime.Scheme
}

//+kubebuilder:rbac:groups=nodeobservability.olm.openshift.io,resources=nodeobservabilities,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=nodeobservability.olm.openshift.io,resources=nodeobservabilities/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=nodeobservability.olm.openshift.io,resources=nodeobservabilities/finalizers,verbs=update
//+kubebuilder:rbac:groups=apps,resources=daemonsets,verbs=list;get;create;watch;
//+kubebuilder:rbac:groups=core,resources=secrets,verbs=list;get;create;watch;
//+kubebuilder:rbac:groups=core,resources=serviceaccount,verbs=list;get;create;watch;
//+kubebuilder:rbac:groups=rbac,resources=clusterrole,verbs=list;get;create;watch;
//+kubebuilder:rbac:groups=rbac,resources=clusterrolebinding,verbs=list;get;create;watch;
//+kubebuilder:rbac:groups=security,resources=securitycontextconstraint,verbs=list;get;create;watch;

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the NodeObservability object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.10.0/pkg/reconcile
func (r *NodeObservabilityReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        //log := r.Log

        // Fetch the NodeObservability instance
        nodeObs := &amp;v1alpha1.NodeObservability{}
        err := r.Get(ctx, req.NamespacedName, nodeObs)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        // Request object not found, could have been deleted after reconcile request.
                        // Owned objects are automatically garbage collected. For additional cleanup logic use finalizers.
                        // Return and don't requeue
                        r.Log.Info("NodeObservability resource not found. Ignoring since object must be deleted")
                        return ctrl.Result{}, nil
                }</span>
                // Error reading the object - requeue the request.
                <span class="cov0" title="0">r.Log.Error(err, "Failed to get NodeObservability")
                return ctrl.Result{}, err</span>
        }
        <span class="cov8" title="1">r.Log.Info(fmt.Sprintf("NodeObservability resource found : Namespace %s : Name %s ", req.NamespacedName.Namespace, nodeObs.Name))

        // For the pods to deploy on each node and execute the crio &amp; kubelet script we need the following
        // - custom scc (mainly allowHostPathDirPlugin set to true)
        // - serviceaccount
        // - secret
        // - clusterrole (use the scc)
        // - clusterrolebinding (bind the sa to the role)

        // ensure scc
        haveSCC, scc, err := r.ensureSecurityContextConstraints(ctx, nodeObs)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("failed to ensure securitycontectconstraints : %w", err)
        }</span> else<span class="cov8" title="1"> if !haveSCC </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("failed to get securitycontextconstrainrs : %w", err)
        }</span>
        <span class="cov8" title="1">r.Log.Info(fmt.Sprintf("SecurityContextConstraints : %s", scc.Name))

        // ensure secret
        haveSecret, secret, err := r.ensureSecret(ctx, nodeObs)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("failed to ensure secret : %w", err)
        }</span> else<span class="cov8" title="1"> if !haveSecret </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("failed to get secret : %w", err)
        }</span>
        <span class="cov8" title="1">r.Log.Info(fmt.Sprintf("Secret : %s", secret.Name))

        // ensure serviceaccount with the secret
        haveSA, sa, err := r.ensureServiceAccount(ctx, nodeObs, secret)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("failed to ensure serviceaccount : %w", err)
        }</span> else<span class="cov8" title="1"> if !haveSA </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("failed to get serviceaccount : %w", err)
        }</span>
        <span class="cov8" title="1">r.Log.Info(fmt.Sprintf("ServiceAccount : %s", sa.Name))

        // check clusterrole
        haveCR, cr, err := r.ensureClusterRole(ctx, nodeObs)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("failed to ensure clusterrole : %w", err)
        }</span> else<span class="cov8" title="1"> if !haveCR </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("failed to get clusterrole : %w", err)
        }</span>
        <span class="cov8" title="1">r.Log.Info(fmt.Sprintf("ClusterRole : %s", cr.Name))

        // check clusterolebinding with serviceaccount
        haveCRB, crb, err := r.ensureClusterRoleBinding(ctx, nodeObs, sa.Name)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("failed to ensure clusterrolebinding : %w", err)
        }</span> else<span class="cov8" title="1"> if !haveCRB </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("failed to get clusterrolebinding : %w", err)
        }</span>
        <span class="cov8" title="1">r.Log.Info(fmt.Sprintf("ClusterRoleBinding : %s", crb.Name))

        // check daemonset
        haveDS, ds, err := r.ensureDaemonSet(ctx, nodeObs, sa)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("failed to ensure daemonset : %w", err)
        }</span> else<span class="cov8" title="1"> if !haveDS </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("failed to get daemonset : %w", err)
        }</span>
        <span class="cov8" title="1">r.Log.Info(fmt.Sprintf("DaemonSet : %s", ds.Name))

        // check the pods that are deployed against the daemonset count
        podList := &amp;corev1.PodList{}
        listOpts := []client.ListOption{
                client.InNamespace(nodeObs.Namespace),
                client.MatchingLabels(labelsForNodeObservability(nodeObs.Name)),
        }
        if err = r.List(ctx, podList, listOpts...); err != nil </span><span class="cov0" title="0">{
                r.Log.Error(err, "Failed to list pods", "NodeObservability.Namespace", nodeObs.Namespace, "NodeObservability.Name", nodeObs.Name)
                return ctrl.Result{}, err
        }</span>
        <span class="cov8" title="1">count := 0
        for x, pod := range podList.Items </span><span class="cov0" title="0">{
                r.Log.Info(fmt.Sprintf("Pod phase status %d %s", x, pod.Status.Phase))
                if pod.Status.Phase == corev1.PodRunning </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        //if nodeObs.Status.Count != count {
        <span class="cov8" title="1">r.Log.Info("Updating status")
        nodeObs.Status.Count = len(podList.Items)
        now := metav1.NewTime(clock.Now())
        nodeObs.Status.LastUpdate = &amp;now
        err = r.Status().Update(ctx, nodeObs)
        if err != nil </span><span class="cov0" title="0">{
                r.Log.Error(err, "Failed to update status")
                return ctrl.Result{}, err
        }</span>
        <span class="cov8" title="1">r.Log.Info(fmt.Sprintf("Status updated : %d", count))
        //}
        return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *NodeObservabilityReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;v1alpha1.NodeObservability{}).
                Owns(&amp;appsv1.DaemonSet{}).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package nodeobservabilitycontroller

import (
        "context"
        "fmt"

        "github.com/lmzuccarelli/node-observability-operator/api/v1alpha1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
)

const (
        podName          = "node-observability-agent"
        socketName       = "socket"
        path             = "/var/run/crio/crio.sock"
        mountPath        = "/var/run/crio/crio.sock"
        defaultScheduler = "default-scheduler"
)

// ensureDaemonSet ensures that the daemonset exists
// Returns a Boolean value indicating whether it exists, a pointer to the
// daemonset and an error when relevant
func (r *NodeObservabilityReconciler) ensureDaemonSet(ctx context.Context, nodeObs *v1alpha1.NodeObservability, sa *corev1.ServiceAccount) (bool, *appsv1.DaemonSet, error) <span class="cov8" title="1">{
        nameSpace := types.NamespacedName{Namespace: nodeObs.Namespace, Name: nodeObs.Name}
        desired := r.desiredDaemonSet(nodeObs, sa)
        exist, current, err := r.currentDaemonSet(ctx, nameSpace)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("failed to get DaemonSet: %w", err)
        }</span>
        <span class="cov8" title="1">if !exist </span><span class="cov8" title="1">{
                if err := r.createDaemonSet(ctx, desired); err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov8" title="1">return r.currentDaemonSet(ctx, nameSpace)</span>
        }
        // Set NodeObservability instance as the owner and controller
        <span class="cov0" title="0">ctrl.SetControllerReference(nodeObs, desired, r.Scheme)
        return true, current, nil</span>
}

// currentDaemonSet check if the daemonset exists
func (r *NodeObservabilityReconciler) currentDaemonSet(ctx context.Context, nameSpace types.NamespacedName) (bool, *appsv1.DaemonSet, error) <span class="cov8" title="1">{
        ds := &amp;appsv1.DaemonSet{}
        if err := r.Get(ctx, nameSpace, ds); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return false, nil, nil
                }</span>
                <span class="cov0" title="0">return false, nil, err</span>
        }
        <span class="cov8" title="1">return true, ds, nil</span>
}

// createDaemonSet creates the serviceaccount
func (r *NodeObservabilityReconciler) createDaemonSet(ctx context.Context, ds *appsv1.DaemonSet) error <span class="cov8" title="1">{
        if err := r.Create(ctx, ds); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create DaemonSet %s/%s: %w", ds.Namespace, ds.Name, err)
        }</span>
        <span class="cov8" title="1">r.Log.Info("created DaemonSet", "DaemonSet.Namespace", ds.Namespace, "DaemonSet.Name", ds.Name)
        return nil</span>
}

// desiredDaemonSet returns a DaemonSet object
func (r *NodeObservabilityReconciler) desiredDaemonSet(nodeObs *v1alpha1.NodeObservability, sa *corev1.ServiceAccount) *appsv1.DaemonSet <span class="cov8" title="1">{

        ls := labelsForNodeObservability(nodeObs.Name)
        tgp := int64(30)
        vst := corev1.HostPathSocket
        privileged := true

        ds := &amp;appsv1.DaemonSet{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      nodeObs.Name,
                        Namespace: nodeObs.Namespace,
                },
                Spec: appsv1.DaemonSetSpec{
                        Selector: &amp;metav1.LabelSelector{
                                MatchLabels: ls,
                        },
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels: ls,
                                },
                                Spec: corev1.PodSpec{
                                        Containers: []corev1.Container{{
                                                Image:           nodeObs.Spec.Image,
                                                ImagePullPolicy: corev1.PullIfNotPresent,
                                                Name:            podName,
                                                // TODO - this will change once the shell script in the node-observability-agent is
                                                // finalized
                                                Command:                  []string{"/bin/sh", "-c", "curl --unix-socket /var/run/crio/crio.sock http://localhost/debug/pprof/profile &gt; /mnt/crio-${NODE_IP}_$(date +\"%F-%T.%N\").out &amp;&amp; sleep 3600"},
                                                Resources:                corev1.ResourceRequirements{},
                                                TerminationMessagePolicy: corev1.TerminationMessageFallbackToLogsOnError,
                                                SecurityContext: &amp;corev1.SecurityContext{
                                                        Privileged: &amp;privileged,
                                                },
                                                Env: []corev1.EnvVar{{
                                                        Name: "NODE_IP",
                                                        ValueFrom: &amp;corev1.EnvVarSource{
                                                                FieldRef: &amp;corev1.ObjectFieldSelector{
                                                                        FieldPath: "status.hostIP",
                                                                },
                                                        },
                                                }},
                                                VolumeMounts: []corev1.VolumeMount{{
                                                        MountPath: mountPath,
                                                        Name:      socketName,
                                                        ReadOnly:  false,
                                                }},
                                        }},
                                        DNSPolicy:                     corev1.DNSClusterFirst,
                                        RestartPolicy:                 corev1.RestartPolicyAlways,
                                        SchedulerName:                 defaultScheduler,
                                        ServiceAccountName:            sa.Name,
                                        TerminationGracePeriodSeconds: &amp;tgp,
                                        Volumes: []corev1.Volume{{
                                                Name: socketName,
                                                VolumeSource: corev1.VolumeSource{
                                                        HostPath: &amp;corev1.HostPathVolumeSource{
                                                                Path: path,
                                                                Type: &amp;vst,
                                                        },
                                                },
                                        }},
                                        NodeSelector: nodeObs.Spec.Labels,
                                },
                        },
                },
        }
        return ds
}</span>

// labelsForiNodeObservability returns the labels for selecting the resources
// belonging to the given node observability CR name.
func labelsForNodeObservability(name string) map[string]string <span class="cov8" title="1">{
        return map[string]string{"app": "nodeobservability", "nodeobs_cr": name}
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package nodeobservabilitycontroller

import (
        "context"
        "fmt"

        "github.com/lmzuccarelli/node-observability-operator/api/v1alpha1"
        rbacv1 "k8s.io/api/rbac/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
)

const (
        apiGroup               = "rbac.authorization.k8s.io"
        clusterRoleName        = "node-observability-cr"
        clusterRole            = "ClusterRole"
        clusterRoleBindingName = "node-observability-crb"
        serviceAccount         = "ServiceAccount"
        get                    = "get"
        list                   = "list"
        nodes                  = "nodes"
        nodesProxy             = "nodes/proxy"
        pods                   = "pods"
        url                    = "/debug/*"
        secGroup               = "security.openshift.io"
        secResource            = "securitycontextconstraints"
        secResourceName        = "node-observability-scc"
        use                    = "use"
)

// ensureClusterRole ensures that the clusterrole exists
// Returns a Boolean value indicating whether it exists, a pointer to
// cluster role and an error when relevant
func (r *NodeObservabilityReconciler) ensureClusterRole(ctx context.Context, nodeObs *v1alpha1.NodeObservability) (bool, *rbacv1.ClusterRole, error) <span class="cov8" title="1">{
        nameSpace := types.NamespacedName{Namespace: nodeObs.Namespace, Name: clusterRoleName}
        desired := r.desiredClusterRole(nodeObs)
        exist, current, err := r.currentClusterRole(ctx, nameSpace)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("failed to get ClusterRole: %w", err)
        }</span>
        <span class="cov8" title="1">if !exist </span><span class="cov8" title="1">{
                if err := r.createClusterRole(ctx, desired); err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov8" title="1">return r.currentClusterRole(ctx, nameSpace)</span>
        }
        // Set NodeObservability instance as the owner and controller
        <span class="cov0" title="0">ctrl.SetControllerReference(nodeObs, desired, r.Scheme)
        return true, current, nil</span>
}

// currentClusterRole checks that the clusterrole  exists
func (r *NodeObservabilityReconciler) currentClusterRole(ctx context.Context, nameSpace types.NamespacedName) (bool, *rbacv1.ClusterRole, error) <span class="cov8" title="1">{
        cr := &amp;rbacv1.ClusterRole{}
        if err := r.Get(ctx, nameSpace, cr); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return false, nil, nil
                }</span>
                <span class="cov0" title="0">return false, nil, err</span>
        }
        <span class="cov8" title="1">return true, cr, nil</span>
}

// createClusterRole creates the clusterrole
func (r *NodeObservabilityReconciler) createClusterRole(ctx context.Context, cr *rbacv1.ClusterRole) error <span class="cov8" title="1">{
        if err := r.Create(ctx, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create ClusterRole %s/%s: %w", cr.Namespace, cr.Name, err)
        }</span>
        <span class="cov8" title="1">r.Log.Info("created ClusterRole", "ClusterRole.Namespace", cr.Namespace, "ClusterRole.Name", cr.Name)
        return nil</span>
}

// desiredClusterRole returns a clusterrole object
func (r *NodeObservabilityReconciler) desiredClusterRole(nodeObs *v1alpha1.NodeObservability) *rbacv1.ClusterRole <span class="cov8" title="1">{

        cr := &amp;rbacv1.ClusterRole{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      clusterRoleName,
                        Namespace: nodeObs.Namespace,
                        Labels:    labelsForClusterRole(clusterRoleName),
                },
                Rules: []rbacv1.PolicyRule{
                        {
                                APIGroups:     []string{secGroup},
                                Resources:     []string{secResource},
                                ResourceNames: []string{secResourceName},
                                Verbs:         []string{use},
                        },
                        {
                                Verbs:     []string{get, list},
                                APIGroups: []string{""},
                                Resources: []string{nodes, nodesProxy, pods},
                        },
                        {
                                Verbs:           []string{get},
                                NonResourceURLs: []string{url},
                        },
                },
        }
        return cr
}</span>

// ensureClusterRoleBinding ensures that the clusterrolebinding exists
// Returns a Boolean value indicating whether it exists, a pointer to the
// clusterrolebinding and an error when relevant
func (r *NodeObservabilityReconciler) ensureClusterRoleBinding(ctx context.Context, nodeObs *v1alpha1.NodeObservability, saName string) (bool, *rbacv1.ClusterRoleBinding, error) <span class="cov8" title="1">{
        nameSpace := types.NamespacedName{Namespace: nodeObs.Namespace, Name: clusterRoleBindingName}
        desired := r.desiredClusterRoleBinding(nodeObs, saName)
        exist, current, err := r.currentClusterRoleBinding(ctx, nameSpace)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("failed to get ClusterRoleBinding: %w", err)
        }</span>
        <span class="cov8" title="1">if !exist </span><span class="cov8" title="1">{
                if err := r.createClusterRoleBinding(ctx, desired); err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov8" title="1">return r.currentClusterRoleBinding(ctx, nameSpace)</span>
        }
        // Set NodeObservability instance as the owner and controller
        <span class="cov0" title="0">ctrl.SetControllerReference(nodeObs, desired, r.Scheme)
        return true, current, nil</span>
}

// currentClusterRoleBinding checks if the clusterrolebinding exists
func (r *NodeObservabilityReconciler) currentClusterRoleBinding(ctx context.Context, nameSpace types.NamespacedName) (bool, *rbacv1.ClusterRoleBinding, error) <span class="cov8" title="1">{
        crb := &amp;rbacv1.ClusterRoleBinding{}
        if err := r.Get(ctx, nameSpace, crb); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return false, nil, nil
                }</span>
                <span class="cov0" title="0">return false, nil, err</span>
        }
        <span class="cov8" title="1">return true, crb, nil</span>
}

// createClusterRoleBinding creates the clusterrolebinding
func (r *NodeObservabilityReconciler) createClusterRoleBinding(ctx context.Context, crb *rbacv1.ClusterRoleBinding) error <span class="cov8" title="1">{
        if err := r.Create(ctx, crb); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create ClusterRoleBinding %s/%s: %w", crb.Namespace, crb.Name, err)
        }</span>
        <span class="cov8" title="1">r.Log.Info("created ClusterRoleBinding", "ClusterRoleBinding.Namespace", crb.Namespace, "ClusterRoleBinding.Name", crb.Name)
        return nil</span>
}

// desiredClusterRoleBinding returns a clusterrolebinding object
func (r *NodeObservabilityReconciler) desiredClusterRoleBinding(nodeObs *v1alpha1.NodeObservability, saName string) *rbacv1.ClusterRoleBinding <span class="cov8" title="1">{

        crb := &amp;rbacv1.ClusterRoleBinding{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      clusterRoleBindingName,
                        Namespace: nodeObs.Namespace,
                },
                Subjects: []rbacv1.Subject{
                        {
                                Kind:      serviceAccount,
                                Name:      saName,
                                Namespace: nodeObs.Namespace,
                        },
                },
                RoleRef: rbacv1.RoleRef{
                        Kind:     clusterRole,
                        Name:     clusterRoleName,
                        APIGroup: apiGroup,
                },
        }
        return crb
}</span>

// labelsForclusterRole returns the labels for selecting the resources
func labelsForClusterRole(name string) map[string]string <span class="cov8" title="1">{
        return map[string]string{"scc": "node-observability-scc-role", "role": name}
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package nodeobservabilitycontroller

import (
        "context"
        "fmt"

        "github.com/lmzuccarelli/node-observability-operator/api/v1alpha1"
        securityv1 "github.com/openshift/api/security/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
)

const (
        sccName = "node-observability-scc"
)

// ensureSecurityContextConstraints ensures that the securitycontextconstraints exists
// Returns a Boolean value indicatiing whether it exists, a pointer to the
// securitycontextconstraints and an error when relevant
func (r *NodeObservabilityReconciler) ensureSecurityContextConstraints(ctx context.Context, nodeObs *v1alpha1.NodeObservability) (bool, *securityv1.SecurityContextConstraints, error) <span class="cov8" title="1">{
        desired := r.desiredSecurityContextConstraints(nodeObs)
        exist, current, err := r.currentSecurityContextConstraints(ctx, nodeObs)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("failed to get SecurityContextConstraints: %w", err)
        }</span>
        <span class="cov8" title="1">if !exist </span><span class="cov8" title="1">{
                if err := r.createSecurityContextConstraints(ctx, desired); err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov8" title="1">return r.currentSecurityContextConstraints(ctx, nodeObs)</span>
        }
        // Set NodeObservability instance as the owner and controller
        <span class="cov0" title="0">ctrl.SetControllerReference(nodeObs, desired, r.Scheme)
        return true, current, nil</span>
}

// currentSecurityContextConstraints checks that the securitycontextconstraints exists
func (r *NodeObservabilityReconciler) currentSecurityContextConstraints(ctx context.Context, nodeObs *v1alpha1.NodeObservability) (bool, *securityv1.SecurityContextConstraints, error) <span class="cov8" title="1">{
        nameSpace := types.NamespacedName{Namespace: nodeObs.Namespace, Name: sccName}
        scc := &amp;securityv1.SecurityContextConstraints{}
        if err := r.Get(ctx, nameSpace, scc); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return false, nil, nil
                }</span>
                <span class="cov0" title="0">return false, nil, err</span>
        }
        <span class="cov8" title="1">return true, scc, nil</span>
}

// createSecurityContextConstraints creates the securitycontextconstraints
func (r *NodeObservabilityReconciler) createSecurityContextConstraints(ctx context.Context, scc *securityv1.SecurityContextConstraints) error <span class="cov8" title="1">{
        if err := r.Create(ctx, scc); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create SecurityContextConstraint %s/%s: %w", scc.Namespace, scc.Name, err)
        }</span>
        <span class="cov8" title="1">r.Log.Info("created SecurityContextConstraints", "SecurityContextConstraints.Namespace", scc.Namespace, "SecurityContextConstraints.Name", scc.Name)
        return nil</span>
}

// desiredSecurityContextConstraints en the desired securitycontextconstraints
func (r *NodeObservabilityReconciler) desiredSecurityContextConstraints(nodeObs *v1alpha1.NodeObservability) *securityv1.SecurityContextConstraints <span class="cov8" title="1">{

        var priority int32 = 10

        scc := &amp;securityv1.SecurityContextConstraints{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      sccName,
                        Namespace: nodeObs.Namespace,
                },
                AllowPrivilegedContainer: true,
                AllowHostIPC:             false,
                AllowHostNetwork:         true,
                AllowHostPID:             false,
                AllowHostPorts:           false,
                // This allows us to mount the hosts /var/run/crio/crio.sock into the container
                AllowHostDirVolumePlugin: true,
                AllowedCapabilities:      nil,
                DefaultAddCapabilities:   nil,
                FSGroup: securityv1.FSGroupStrategyOptions{
                        Type: securityv1.FSGroupStrategyRunAsAny,
                },
                Groups:                   []string{"system:cluster-admins", "system:nodes"},
                Priority:                 &amp;priority,
                ReadOnlyRootFilesystem:   false,
                RequiredDropCapabilities: []corev1.Capability{"MKNOD"},
                RunAsUser: securityv1.RunAsUserStrategyOptions{
                        Type: securityv1.RunAsUserStrategyRunAsAny,
                },
                SELinuxContext: securityv1.SELinuxContextStrategyOptions{
                        Type: securityv1.SELinuxStrategyMustRunAs,
                },
                SupplementalGroups: securityv1.SupplementalGroupsStrategyOptions{
                        Type: securityv1.SupplementalGroupsStrategyRunAsAny,
                },
                Volumes: []securityv1.FSType{securityv1.FSTypeHostPath, securityv1.FSTypeSecret},
        }
        return scc
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package nodeobservabilitycontroller

import (
        "context"
        "fmt"

        "github.com/lmzuccarelli/node-observability-operator/api/v1alpha1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
)

const (
        secretName = "node-observability-secret"
)

// ensureSecret ensures that the secret exists
// Returns a Boolean value indicating whether it exists, a pointer to the
// secret and an error when relevant
func (r *NodeObservabilityReconciler) ensureSecret(ctx context.Context, nodeObs *v1alpha1.NodeObservability) (bool, *corev1.Secret, error) <span class="cov8" title="1">{
        nameSpace := types.NamespacedName{Namespace: nodeObs.Namespace, Name: secretName}
        desired := r.desiredSecret(nodeObs)
        exist, current, err := r.currentSecret(ctx, nameSpace)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("failed to get Secret: %w", err)
        }</span>
        <span class="cov8" title="1">if !exist </span><span class="cov8" title="1">{
                if err := r.createSecret(ctx, desired); err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov8" title="1">return r.currentSecret(ctx, nameSpace)</span>
        }
        // Set NodeObservability instance as the owner and controller
        <span class="cov0" title="0">ctrl.SetControllerReference(nodeObs, desired, r.Scheme)
        return true, current, nil</span>
}

// currentSecret checks that the serviceaccount exists
func (r *NodeObservabilityReconciler) currentSecret(ctx context.Context, nameSpace types.NamespacedName) (bool, *corev1.Secret, error) <span class="cov8" title="1">{
        secret := &amp;corev1.Secret{}
        if err := r.Get(ctx, nameSpace, secret); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return false, nil, nil
                }</span>
                <span class="cov0" title="0">return false, nil, err</span>
        }
        <span class="cov8" title="1">return true, secret, nil</span>
}

// createSecret creates the serviceaccount
func (r *NodeObservabilityReconciler) createSecret(ctx context.Context, secret *corev1.Secret) error <span class="cov8" title="1">{
        if err := r.Create(ctx, secret); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Secret %s/%s: %w", secret.Namespace, secret.Name, err)
        }</span>
        <span class="cov8" title="1">r.Log.Info("created Secret", "Secret.Namespace", secret.Namespace, "Secret.Name", secret.Name)
        return nil</span>
}

// desiredSecret returns a Secret object
func (r *NodeObservabilityReconciler) desiredSecret(nodeObs *v1alpha1.NodeObservability) *corev1.Secret <span class="cov8" title="1">{

        s := &amp;corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Namespace:   nodeObs.Namespace,
                        Name:        secretName,
                        Annotations: annotationsForSecret(),
                },
                Type: corev1.SecretTypeServiceAccountToken,
        }
        return s
}</span>

// annotationsForSecret returns the annotations for the secret
func annotationsForSecret() map[string]string <span class="cov8" title="1">{
        return map[string]string{"kubernetes.io/service-account.name": "profiling"}
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package nodeobservabilitycontroller

import (
        "context"
        "fmt"

        "github.com/lmzuccarelli/node-observability-operator/api/v1alpha1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
)

const (
        serviceAccountName = "node-observability-sa"
)

// ensureServiceAccount ensures that the serviceaccount exists
// Returns a Boolean value indicating whether it exists, a pointer to the
// serviceaccount and an error when relevant
func (r *NodeObservabilityReconciler) ensureServiceAccount(ctx context.Context, nodeObs *v1alpha1.NodeObservability, secret *corev1.Secret) (bool, *corev1.ServiceAccount, error) <span class="cov8" title="1">{
        nameSpace := types.NamespacedName{Namespace: nodeObs.Namespace, Name: serviceAccountName}
        desired := r.desiredServiceAccount(nodeObs, secret)
        exist, current, err := r.currentServiceAccount(ctx, nameSpace)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("failed to get ServiceAccount: %w", err)
        }</span>
        <span class="cov8" title="1">if !exist </span><span class="cov8" title="1">{
                if err := r.createServiceAccount(ctx, desired); err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov8" title="1">return r.currentServiceAccount(ctx, nameSpace)</span>
        }
        // Set NodeObservability instance as the owner and controller
        <span class="cov0" title="0">ctrl.SetControllerReference(nodeObs, desired, r.Scheme)
        return true, current, nil</span>
}

// currentServiceAccount checks that the serviceaccount exists
func (r *NodeObservabilityReconciler) currentServiceAccount(ctx context.Context, nameSpace types.NamespacedName) (bool, *corev1.ServiceAccount, error) <span class="cov8" title="1">{
        sa := &amp;corev1.ServiceAccount{}
        if err := r.Get(ctx, nameSpace, sa); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return false, nil, nil
                }</span>
                <span class="cov0" title="0">return false, nil, err</span>
        }
        <span class="cov8" title="1">return true, sa, nil</span>
}

// createServiceAccount creates the serviceaccount
func (r *NodeObservabilityReconciler) createServiceAccount(ctx context.Context, sa *corev1.ServiceAccount) error <span class="cov8" title="1">{
        if err := r.Create(ctx, sa); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create ServiceAccount %s/%s: %w", sa.Namespace, sa.Name, err)
        }</span>
        <span class="cov8" title="1">r.Log.Info("created ServiceAccount", "ServiceAccount.Namespace", sa.Namespace, "ServiceAccount.Name", sa.Name)
        return nil</span>
}

// desiredServiceAccount returns a serviceaccount object
func (r *NodeObservabilityReconciler) desiredServiceAccount(nodeObs *v1alpha1.NodeObservability, secret *corev1.Secret) *corev1.ServiceAccount <span class="cov8" title="1">{

        sa := &amp;corev1.ServiceAccount{
                ObjectMeta: metav1.ObjectMeta{
                        Namespace: nodeObs.Namespace,
                        Name:      serviceAccountName,
                },
                Secrets: []corev1.ObjectReference{{
                        Name: secret.Name,
                }},
        }
        return sa
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
